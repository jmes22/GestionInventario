Angular CLI: 18.2.11
Node: 22.11.0
Package Manager: npm 10.9.0
OS: win32 x64
Angular:
...
Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1802.11 (cli-only)
@angular-devkit/core         18.2.11 (cli-only)
@angular-devkit/schematics   18.2.11 (cli-only)
@schematics/angular          18.2.11 (cli-only)

Con esa version de angular crea un programa paso que sea:
* Login con JWT.
* Pantalla principal con lista de productos
* Acción eliminar producto
* Formulario para agregar producto.

La api escucha en https://localhost:7187
El usuario es:
public class Usuario
{
    public int UsuarioId { get; set; }
    public string Email { get; set; }
    public string Password { get; set; }
}

La respuesta del end point /api/Auth/login es:
{
  "user": {
    "usuarioId": 1,
    "email": "user@example.com",
    "password": "securePassword123"
  },
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJqdGkiOiJmYzIxMThhOS1jMjg5LTQ4OGYtYmM4MS1jZjI1N2JkOTYwY2MiLCJleHAiOjE3MzA5MzEyMzgsImlzcyI6Imh0dHBzOi8vbG9jYWxob3N0OjcxODciLCJhdWQiOiJodHRwczovL2xvY2FsaG9zdDo3MTg3In0.1QjIJywyghBfYdZkYI4vNSbuadO56KQdxfIOFcWl_0s"
}
Quiero paso como construirlo.

Te ayudaré a crear una aplicación Angular con las funcionalidades solicitadas paso a paso.

1. Primero, vamos a crear un nuevo proyecto Angular:

```bash
ng new productos-app
cd productos-app
```

Durante la creación, selecciona:
- Routing: Yes
- CSS: CSS

2. Instalar las dependencias necesarias:

```bash
npm install @angular/material @auth0/angular-jwt
```

3. Vamos a crear los modelos necesarios:



```typescript
// src/app/models/usuario.model.ts
export interface Usuario {
  usuarioId: number;
  email: string;
  password: string;
}

export interface AuthResponse {
  user: Usuario;
  token: string;
}

// src/app/models/producto.model.ts
export interface Producto {
  productoId: number;
  nombre: string;
  precio: number;
  descripcion: string;
}

```

4. Crear los servicios necesarios:



```typescript
// src/app/services/auth.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Usuario, AuthResponse } from '../models/usuario.model';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = 'https://localhost:7187/api/Auth';
  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);
  isAuthenticated$ = this.isAuthenticatedSubject.asObservable();

  constructor(private http: HttpClient) {
    this.isAuthenticatedSubject.next(!!localStorage.getItem('token'));
  }

  login(email: string, password: string): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.apiUrl}/login`, { email, password })
      .pipe(
        tap(response => {
          localStorage.setItem('token', response.token);
          this.isAuthenticatedSubject.next(true);
        })
      );
  }

  logout(): void {
    localStorage.removeItem('token');
    this.isAuthenticatedSubject.next(false);
  }
}

// src/app/services/producto.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { Producto } from '../models/producto.model';

@Injectable({
  providedIn: 'root'
})
export class ProductoService {
  private apiUrl = 'https://localhost:7187/api/Productos';

  constructor(private http: HttpClient) { }

  getProductos(): Observable<Producto[]> {
    return this.http.get<Producto[]>(this.apiUrl);
  }

  agregarProducto(producto: Producto): Observable<Producto> {
    return this.http.post<Producto>(this.apiUrl, producto);
  }

  eliminarProducto(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }
}

```

5. Configurar el interceptor para JWT:



```typescript
// src/app/interceptors/jwt.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = localStorage.getItem('token');
    
    if (token) {
      request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${token}`
        }
      });
    }
    
    return next.handle(request);
  }
}

```

6. Crear los componentes necesarios:



```typescript
// src/app/components/login/login.component.ts
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { AuthService } from '../../services/auth.service';

@Component({
  selector: 'app-login',
  template: `
    <div class="login-container">
      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
        <h2>Iniciar Sesión</h2>
        
        <mat-form-field>
          <mat-label>Email</mat-label>
          <input matInput formControlName="email" type="email">
          <mat-error *ngIf="loginForm.get('email')?.hasError('required')">
            El email es requerido
          </mat-error>
        </mat-form-field>

        <mat-form-field>
          <mat-label>Contraseña</mat-label>
          <input matInput formControlName="password" type="password">
          <mat-error *ngIf="loginForm.get('password')?.hasError('required')">
            La contraseña es requerida
          </mat-error>
        </mat-form-field>

        <button mat-raised-button color="primary" type="submit" [disabled]="loginForm.invalid">
          Iniciar Sesión
        </button>
      </form>
    </div>
  `,
  styles: [`
    .login-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    form {
      display: flex;
      flex-direction: column;
      width: 300px;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    mat-form-field {
      margin-bottom: 20px;
    }
  `]
})
export class LoginComponent {
  loginForm: FormGroup;

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router
  ) {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required]
    });
  }

  onSubmit(): void {
    if (this.loginForm.valid) {
      const { email, password } = this.loginForm.value;
      this.authService.login(email, password).subscribe({
        next: () => this.router.navigate(['/productos']),
        error: err => console.error('Error en login:', err)
      });
    }
  }
}

// src/app/components/productos/productos.component.ts
import { Component, OnInit } from '@angular/core';
import { ProductoService } from '../../services/producto.service';
import { Producto } from '../../models/producto.model';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Lista de Productos</h2>
      
      <button mat-raised-button color="primary" (click)="mostrarFormulario = true">
        Agregar Producto
      </button>

      <table mat-table [dataSource]="productos" class="mat-elevation-z8">
        <ng-container matColumnDef="nombre">
          <th mat-header-cell *matHeaderCellDef> Nombre </th>
          <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
        </ng-container>

        <ng-container matColumnDef="precio">
          <th mat-header-cell *matHeaderCellDef> Precio </th>
          <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
        </ng-container>

        <ng-container matColumnDef="descripcion">
          <th mat-header-cell *matHeaderCellDef> Descripción </th>
          <td mat-cell *matCellDef="let producto"> {{producto.descripcion}} </td>
        </ng-container>

        <ng-container matColumnDef="acciones">
          <th mat-header-cell *matHeaderCellDef> Acciones </th>
          <td mat-cell *matCellDef="let producto">
            <button mat-icon-button color="warn" (click)="eliminarProducto(producto.productoId)">
              <mat-icon>delete</mat-icon>
            </button>
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="columnas"></tr>
        <tr mat-row *matRowDef="let row; columns: columnas;"></tr>
      </table>

      <div *ngIf="mostrarFormulario" class="formulario-container">
        <form [formGroup]="productoForm" (ngSubmit)="agregarProducto()">
          <mat-form-field>
            <mat-label>Nombre</mat-label>
            <input matInput formControlName="nombre">
          </mat-form-field>

          <mat-form-field>
            <mat-label>Precio</mat-label>
            <input matInput type="number" formControlName="precio">
          </mat-form-field>

          <mat-form-field>
            <mat-label>Descripción</mat-label>
            <textarea matInput formControlName="descripcion"></textarea>
          </mat-form-field>

          <div class="form-actions">
            <button mat-raised-button color="primary" type="submit">Guardar</button>
            <button mat-button (click)="mostrarFormulario = false">Cancelar</button>
          </div>
        </form>
      </div>
    </div>
  `,
  styles: [`
    .productos-container {
      padding: 20px;
    }
    table {
      width: 100%;
      margin-top: 20px;
    }
    .formulario-container {
      max-width: 500px;
      margin: 20px auto;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .form-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    mat-form-field {
      width: 100%;
      margin-bottom: 20px;
    }
  `]
})
export class ProductosComponent implements OnInit {
  productos: Producto[] = [];
  columnas = ['nombre', 'precio', 'descripcion', 'acciones'];
  mostrarFormulario = false;
  productoForm: FormGroup;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder
  ) {
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      precio: [0, [Validators.required, Validators.min(0)]],
      descripcion: ['']
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => this.productos = productos,
      error: (err) => console.error('Error al cargar productos:', err)
    });
  }

  eliminarProducto(id: number): void {
    this.productoService.eliminarProducto(id).subscribe({
      next: () => this.cargarProductos(),
      error: (err) => console.error('Error al eliminar producto:', err)
    });
  }

  agregarProducto(): void {
    if (this.productoForm.valid) {
      this.productoService.agregarProducto(this.productoForm.value).subscribe({
        next: () => {
          this.cargarProductos();
          this.mostrarFormulario = false;
          this.productoForm.reset();
        },
        error: (err) => console.error('Error al agregar producto:', err)
      });
    }
  }
}

```

7. Actualizar el módulo principal:



```typescript
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { RouterModule, Routes } from '@angular/router';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { ReactiveFormsModule } from '@angular/forms';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';

import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { ProductosComponent } from './components/productos/productos.component';
import { JwtInterceptor } from './interceptors/jwt.interceptor';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'productos', component: ProductosComponent, canActivate: [AuthGuard] },
  { path: '', redirectTo: '/productos', pathMatch: 'full' }
];

@NgModule({
  declarations: [
    AppComponent,
    LoginComponent,
    ProductosComponent
  ],
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    HttpClientModule,
    ReactiveFormsModule,
    RouterModule.forRoot(routes),
    MatInputModule,
    MatButtonModule,
    MatTableModule,
    MatIconModule,
    MatFormFieldModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

// src/app/guards/auth.guard.ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate
```


continua generando desde este archivo // src/app/guards/auth.guard.ts

Continuaré con el guard de autenticación y añadiré el componente principal de la aplicación.

```typescript
// src/app/guards/auth.guard.ts
import { Injectable } from '@angular/core';
import { 
  CanActivate, 
  ActivatedRouteSnapshot, 
  RouterStateSnapshot, 
  Router 
} from '@angular/router';
import { Observable } from 'rxjs';
import { map, take } from 'rxjs/operators';
import { AuthService } from '../services/auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean> {
    return this.authService.isAuthenticated$.pipe(
      take(1),
      map(isAuthenticated => {
        if (!isAuthenticated) {
          this.router.navigate(['/login']);
          return false;
        }
        return true;
      })
    );
  }
}

```

Ahora, vamos a crear el componente principal de la aplicación que servirá como contenedor:

```typescript
// src/app/app.component.ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from './services/auth.service';

@Component({
  selector: 'app-root',
  template: `
    <div class="app-container">
      <mat-toolbar color="primary" *ngIf="authService.isAuthenticated$ | async">
        <span>Gestión de Productos</span>
        <span class="spacer"></span>
        <button mat-button (click)="logout()">
          <mat-icon>exit_to_app</mat-icon>
          Cerrar Sesión
        </button>
      </mat-toolbar>

      <div class="content">
        <router-outlet></router-outlet>
      </div>
    </div>
  `,
  styles: [`
    .app-container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .spacer {
      flex: 1 1 auto;
    }
    mat-toolbar {
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .content {
      flex: 1;
      padding: 20px;
    }
  `]
})
export class AppComponent {
  constructor(
    public authService: AuthService,
    private router: Router
  ) {}

  logout(): void {
    this.authService.logout();
    this.router.navigate(['/login']);
  }
}

```

También necesitaremos actualizar los estilos globales:

```css
/* src/styles.css */
@import '@angular/material/prebuilt-themes/indigo-pink.css';

html, body {
  height: 100%;
  margin: 0;
  font-family: Roboto, "Helvetica Neue", sans-serif;
}

.mat-form-field {
  width: 100%;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

/* Estilos para los formularios */
.form-container {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
}

.form-field {
  margin-bottom: 20px;
}

/* Estilos para las tablas */
.table-container {
  margin-top: 20px;
  overflow-x: auto;
}

.mat-table {
  width: 100%;
}

.mat-header-cell {
  font-weight: bold;
  color: rgba(0, 0, 0, 0.87);
}

.mat-cell {
  padding: 8px;
}

/* Estilos para los botones */
.action-buttons {
  display: flex;
  gap: 8px;
}

/* Estilos para mensajes de error */
.error-message {
  color: #f44336;
  margin: 8px 0;
}

/* Estilos para los spinners de carga */
.loading-spinner {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

```

Para completar la configuración, necesitarás actualizar el `angular.json` para incluir los estilos de Material:

```json
{
  "projects": {
    "your-app-name": {
      "architect": {
        "build": {
          "options": {
            "styles": [
              "src/styles.css",
              "node_modules/@angular/material/prebuilt-themes/indigo-pink.css"
            ]
          }
        }
      }
    }
  }
}
```

Pasos finales para ejecutar la aplicación:

1. Asegúrate de que todas las dependencias estén instaladas:
```bash
npm install @angular/material @angular/cdk @angular/animations
```

2. Inicia el servidor de desarrollo:
```bash
ng serve
```

La aplicación ahora debería estar funcionando con:
- Un sistema de autenticación JWT
- Protección de rutas con AuthGuard
- Una interfaz de usuario Material Design
- CRUD de productos
- Manejo de sesiones
- Interceptor para añadir el token a las peticiones
- Estilos responsive y profesionales

Puedes acceder a la aplicación en `http://localhost:4200`. La primera pantalla será el login, y una vez autenticado, serás redirigido a la lista de productos.

¿Necesitas ayuda con alguna parte específica o quieres que profundicemos en algún aspecto en particular?

ng new --no-standalone productos-app 
Pregunta
? Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)?

Para este caso, puedes seleccionar "No" ya que:

1. No necesitamos SSR (Server-Side Rendering) ni SSG (Static Site Generation) porque:
- Es una aplicación interna/administrativa
- No requiere optimización SEO
- No necesita un primer renderizado más rápido desde el servidor
- La aplicación maneja estados de autenticación y datos dinámicos

2. Mantener la aplicación como Client-Side Rendering (CSR) es suficiente porque:
- Los usuarios necesitarán estar autenticados
- La data se carga dinámicamente después del login
- El tamaño de la aplicación es relativamente pequeño
- No hay necesidad de pre-renderizar contenido estático

Así que responde "No" a la pregunta:
```bash
? Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)? No
```

Después podremos continuar con la instalación de las dependencias y la configuración del proyecto.

Comparto los errores que dio ng serve.
 [ERROR] TS-996001: The class 'ProductosComponent' is listed in the declarations of the NgModule 'AppModule', but is not a directive, a component, or a pipe. Either remove it from the NgModule's declarations, or add an appropriate Angular decorator. [plugin angular-compiler]
    src/app/app.module.ts:29:4:
      29 │     ProductosComponent
         ╵     ~~~~~~~~~~~~~~~~~~
  'ProductosComponent' is declared here.
    src/app/productos/productos.component.ts:10:13:
      10 │ export class ProductosComponent implements OnInit {
         ╵              ~~~~~~~~~~~~~~~~~~
X [ERROR] TS2304: Cannot find name 'FormGroup'. [plugin angular-compiler]
    src/app/productos/productos.component.ts:14:16:
      14 │   productoForm: FormGroup;
         ╵                 ~~~~~~~~~
X [ERROR] TS-992003: No suitable injection token for parameter 'fb' of class 'ProductosComponent'.
  Consider using the @Inject decorator to specify an injection token. [plugin angular-compiler]
    src/app/productos/productos.component.ts:18:12:
      18 │     private fb: FormBuilder
         ╵             ~~
  This type does not have a value, so it cannot be used as injection token.
    src/app/productos/productos.component.ts:18:16:
      18 │     private fb: FormBuilder
         ╵                 ~~~~~~~~~~~
X [ERROR] TS2304: Cannot find name 'FormBuilder'. [plugin angular-compiler]
    src/app/productos/productos.component.ts:18:16:
      18 │     private fb: FormBuilder
         ╵                 ~~~~~~~~~~~
X [ERROR] TS2304: Cannot find name 'Validators'. [plugin angular-compiler]
    src/app/productos/productos.component.ts:21:19:
      21 │       nombre: ['', Validators.required],
         ╵                    ~~~~~~~~~~
X [ERROR] TS2304: Cannot find name 'Validators'. [plugin angular-compiler]
    src/app/productos/productos.component.ts:22:19:
      22 │       precio: [0, [Validators.required, Validators.min(0)]],
         ╵                    ~~~~~~~~~~
X [ERROR] TS2304: Cannot find name 'Validators'. [plugin angular-compiler]
    src/app/productos/productos.component.ts:22:40:
      22 │       precio: [0, [Validators.required, Validators.min(0)]],
	  
Veo que faltan algunas importaciones necesarias en el componente de productos. Vamos a corregirlo:

```typescript
// src/app/productos/productos.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ProductoService } from '../services/producto.service';
import { Producto } from '../models/producto.model';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Lista de Productos</h2>
      
      <button mat-raised-button color="primary" (click)="mostrarFormulario = true">
        Agregar Producto
      </button>

      <table mat-table [dataSource]="productos" class="mat-elevation-z8">
        <ng-container matColumnDef="nombre">
          <th mat-header-cell *matHeaderCellDef> Nombre </th>
          <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
        </ng-container>

        <ng-container matColumnDef="precio">
          <th mat-header-cell *matHeaderCellDef> Precio </th>
          <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
        </ng-container>

        <ng-container matColumnDef="descripcion">
          <th mat-header-cell *matHeaderCellDef> Descripción </th>
          <td mat-cell *matCellDef="let producto"> {{producto.descripcion}} </td>
        </ng-container>

        <ng-container matColumnDef="acciones">
          <th mat-header-cell *matHeaderCellDef> Acciones </th>
          <td mat-cell *matCellDef="let producto">
            <button mat-icon-button color="warn" (click)="eliminarProducto(producto.productoId)">
              <mat-icon>delete</mat-icon>
            </button>
          </td>
        </ng-container>

        <tr mat-header-row *matHeaderRowDef="columnas"></tr>
        <tr mat-row *matRowDef="let row; columns: columnas;"></tr>
      </table>

      <div *ngIf="mostrarFormulario" class="formulario-container">
        <form [formGroup]="productoForm" (ngSubmit)="agregarProducto()">
          <mat-form-field>
            <mat-label>Nombre</mat-label>
            <input matInput formControlName="nombre">
          </mat-form-field>

          <mat-form-field>
            <mat-label>Precio</mat-label>
            <input matInput type="number" formControlName="precio">
          </mat-form-field>

          <mat-form-field>
            <mat-label>Descripción</mat-label>
            <textarea matInput formControlName="descripcion"></textarea>
          </mat-form-field>

          <div class="form-actions">
            <button mat-raised-button color="primary" type="submit">Guardar</button>
            <button mat-button (click)="mostrarFormulario = false">Cancelar</button>
          </div>
        </form>
      </div>
    </div>
  `,
  styles: [`
    .productos-container {
      padding: 20px;
    }
    table {
      width: 100%;
      margin-top: 20px;
    }
    .formulario-container {
      max-width: 500px;
      margin: 20px auto;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .form-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    mat-form-field {
      width: 100%;
      margin-bottom: 20px;
    }
  `]
})
export class ProductosComponent implements OnInit {
  productos: Producto[] = [];
  columnas = ['nombre', 'precio', 'descripcion', 'acciones'];
  mostrarFormulario = false;
  productoForm: FormGroup;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder
  ) {
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      precio: [0, [Validators.required, Validators.min(0)]],
      descripcion: ['']
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => this.productos = productos,
      error: (err) => console.error('Error al cargar productos:', err)
    });
  }

  eliminarProducto(id: number): void {
    this.productoService.eliminarProducto(id).subscribe({
      next: () => this.cargarProductos(),
      error: (err) => console.error('Error al eliminar producto:', err)
    });
  }

  agregarProducto(): void {
    if (this.productoForm.valid) {
      this.productoService.agregarProducto(this.productoForm.value).subscribe({
        next: () => {
          this.cargarProductos();
          this.mostrarFormulario = false;
          this.productoForm.reset();
        },
        error: (err) => console.error('Error al agregar producto:', err)
      });
    }
  }
}

```

También necesitamos asegurarnos de que el módulo principal tenga todas las importaciones necesarias:

```typescript
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { RouterModule, Routes } from '@angular/router';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { ReactiveFormsModule } from '@angular/forms';

// Material Imports
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatToolbarModule } from '@angular/material/toolbar';

// Components
import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { ProductosComponent } from './productos/productos.component';

// Services and Guards
import { JwtInterceptor } from './interceptors/jwt.interceptor';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'productos', component: ProductosComponent, canActivate: [AuthGuard] },
  { path: '', redirectTo: '/productos', pathMatch: 'full' }
];

@NgModule({
  declarations: [
    AppComponent,
    LoginComponent,
    ProductosComponent
  ],
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    HttpClientModule,
    ReactiveFormsModule,
    RouterModule.forRoot(routes),
    // Material Modules
    MatInputModule,
    MatButtonModule,
    MatTableModule,
    MatIconModule,
    MatFormFieldModule,
    MatToolbarModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

Asegúrate de tener todas las dependencias instaladas:

```bash
ng add @angular/material
npm install @auth0/angular-jwt
```

Los errores que estabas viendo eran principalmente por falta de importaciones. Los cambios principales fueron:

1. Añadir la importación de `FormBuilder, FormGroup, Validators` desde '@angular/forms'
2. Asegurarnos de que `ReactiveFormsModule` está importado en el `AppModule`
3. Añadir todas las importaciones necesarias de Material
4. Actualizar los paths de los componentes

Ahora `ng serve` debería funcionar correctamente. ¿Necesitas ayuda con algo más o sigues viendo algún error?

Access to XMLHttpRequest at 'https://localhost:7187/api/Auth/login' from origin 'http://localhost:4200' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.

comparto el loguin de la api
  [HttpPost("login")]
  public async Task<IActionResult> Login(Entity.Usuario usuario)
  {
      var user = await _usuarioService.GetUsuarioAsync(usuario);
      var claims = new[]
      {
          new Claim(JwtRegisteredClaimNames.Email, user.Email),
          new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
      };
      var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
      var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
      var token = new JwtSecurityToken(
          issuer: _configuration["Jwt:Issuer"],
          audience: _configuration["Jwt:Audience"],
          claims: claims,
          expires: DateTime.Now.AddMinutes(Convert.ToDouble(_configuration["Jwt:ExpireMinutes"])),
          signingCredentials: creds);
      return Ok(new {
          user,
          token = new JwtSecurityTokenHandler().WriteToken(token)
      });
  }

program.cs
var jwtSettings = builder.Configuration.GetSection("Jwt");
var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings["Key"]));
// Configuración de autenticación JWT
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings["Issuer"],
            ValidAudience = jwtSettings["Audience"],
            IssuerSigningKey = key
        };
    });
appsettings.json
{
  "ConnectionStrings": {
    "DatabaseConnection": "Server=JSALGUERO\\SQLEXPRESS;Database=GestionDeInventario;User Id=admin;Password=admin;TrustServerCertificate=true;"
  },
  "Jwt": {
    "Key": "YourVeryLongAndSecureKeyGoesHere",
    "Issuer": "https://localhost:7187",
    "Audience": "https://localhost:7187",
    "ExpireMinutes": 30
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

Para solucionar el error de CORS, necesitas configurar la política de CORS en tu API de .NET. Aquí te muestro cómo hacerlo:

1. Primero, actualiza tu `Program.cs` para incluir la configuración de CORS antes de la configuración de autenticación:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();

// Configuración de CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAngularApp",
        builder =>
        {
            builder.WithOrigins("http://localhost:4200")
                   .AllowAnyMethod()
                   .AllowAnyHeader()
                   .AllowCredentials();
        });
});

// Configuración JWT existente
var jwtSettings = builder.Configuration.GetSection("Jwt");
var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings["Key"]));
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = jwtSettings["Issuer"],
            ValidAudience = jwtSettings["Audience"],
            IssuerSigningKey = key
        };
    });

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// Usar CORS - IMPORTANTE: debe ir antes de UseAuthentication y UseAuthorization
app.UseCors("AllowAngularApp");

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();

```

2. También necesitarás actualizar el controlador de Auth para asegurarte de que permita las solicitudes de CORS:

```csharp
[Route("api/[controller]")]
[ApiController]
[EnableCors("AllowAngularApp")]  // Añade este atributo
public class AuthController : ControllerBase
{
    private readonly IConfiguration _configuration;
    private readonly IUsuarioService _usuarioService;

    public AuthController(IConfiguration configuration, IUsuarioService usuarioService)
    {
        _configuration = configuration;
        _usuarioService = usuarioService;
    }

    [HttpPost("login")]
    public async Task<IActionResult> Login(Entity.Usuario usuario)
    {
        try 
        {
            var user = await _usuarioService.GetUsuarioAsync(usuario);
            if (user == null)
            {
                return Unauthorized(new { message = "Credenciales inválidas" });
            }

            var claims = new[]
            {
                new Claim(JwtRegisteredClaimNames.Email, user.Email),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
            };

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Key"]));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var token = new JwtSecurityToken(
                issuer: _configuration["Jwt:Issuer"],
                audience: _configuration["Jwt:Audience"],
                claims: claims,
                expires: DateTime.Now.AddMinutes(Convert.ToDouble(_configuration["Jwt:ExpireMinutes"])),
                signingCredentials: creds);

            return Ok(new {
                user,
                token = new JwtSecurityTokenHandler().WriteToken(token)
            });
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { message = "Error en el servidor", error = ex.Message });
        }
    }
}

```

3. Por último, asegúrate de que los namespaces necesarios estén importados en ambos archivos:

```csharp
using Microsoft.AspNetCore.Cors;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
```

Esta configuración:
- Permite solicitudes desde tu aplicación Angular (http://localhost:4200)
- Permite cualquier método HTTP (GET, POST, PUT, DELETE, etc.)
- Permite cualquier encabezado en la solicitud
- Habilita el envío de credenciales en las solicitudes CORS

Después de hacer estos cambios:

1. Detén tanto el servidor de .NET como el servidor de Angular
2. Reinicia el servidor de .NET (`dotnet run`)
3. Reinicia el servidor de Angular (`ng serve`)

También verifica que en tu aplicación Angular, el servicio de autenticación esté haciendo la petición correctamente:

```typescript
// src/app/services/auth.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Usuario, AuthResponse } from '../models/usuario.model';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = 'https://localhost:7187/api/Auth';
  private httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    }),
    withCredentials: true
  };

  constructor(private http: HttpClient) {}

  login(email: string, password: string): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(
      `${this.apiUrl}/login`, 
      { email, password },
      this.httpOptions
    ).pipe(
      tap(response => {
        if (response.token) {
          localStorage.setItem('token', response.token);
        }
      })
    );
  }
}

```

Esto debería resolver el error de CORS. ¿Necesitas ayuda con algo más?

comparto los end points de la API para productos:
GET /api/Producto/{id}
PUT /api/Producto/{id}
DELETE /api/Producto/{id}
GET /api/Producto
POST /api/Producto
GET /api/Producto/{nombre} : string

Actualizaré el servicio de productos para manejar todos los endpoints disponibles:

```typescript
// src/app/models/producto.model.ts
export interface Producto {
  productoId?: number;
  nombre: string;
  descripcion: string;
  precio: number;
  stock?: number;
}

export interface ProductoResponse {
  success: boolean;
  data?: Producto;
  message?: string;
}

export interface ProductosResponse {
  success: boolean;
  data?: Producto[];
  message?: string;
}

```

```typescript
// src/app/services/producto.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Producto, ProductoResponse, ProductosResponse } from '../models/producto.model';

@Injectable({
  providedIn: 'root'
})
export class ProductoService {
  private apiUrl = 'https://localhost:7187/api/Producto';
  
  private httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    }),
    withCredentials: true
  };

  constructor(private http: HttpClient) { }

  // Obtener todos los productos
  getProductos(): Observable<Producto[]> {
    return this.http.get<Producto[]>(this.apiUrl, this.httpOptions);
  }

  // Obtener un producto por ID
  getProductoById(id: number): Observable<Producto> {
    return this.http.get<Producto>(`${this.apiUrl}/${id}`, this.httpOptions);
  }

  // Buscar productos por nombre
  searchProductosByNombre(nombre: string): Observable<Producto[]> {
    return this.http.get<Producto[]>(`${this.apiUrl}/${encodeURIComponent(nombre)}`, this.httpOptions);
  }

  // Agregar nuevo producto
  agregarProducto(producto: Producto): Observable<Producto> {
    return this.http.post<Producto>(this.apiUrl, producto, this.httpOptions);
  }

  // Actualizar producto existente
  actualizarProducto(id: number, producto: Producto): Observable<Producto> {
    return this.http.put<Producto>(`${this.apiUrl}/${id}`, producto, this.httpOptions);
  }

  // Eliminar producto
  eliminarProducto(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`, this.httpOptions);
  }
}

```

Ahora actualizaré el componente de productos para incluir todas las funcionalidades:

```typescript
// src/app/productos/productos.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ProductoService } from '../services/producto.service';
import { Producto } from '../models/producto.model';
import { MatSnackBar } from '@angular/material/snack-bar';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Gestión de Productos</h2>
      
      <!-- Barra de búsqueda -->
      <mat-form-field class="search-field">
        <mat-label>Buscar producto</mat-label>
        <input matInput (keyup)="buscarProducto($event)" placeholder="Nombre del producto">
        <button mat-icon-button matSuffix>
          <mat-icon>search</mat-icon>
        </button>
      </mat-form-field>

      <button mat-raised-button color="primary" (click)="mostrarFormulario = true" class="add-button">
        <mat-icon>add</mat-icon> Nuevo Producto
      </button>

      <!-- Tabla de productos -->
      <div class="mat-elevation-z8 table-container">
        <table mat-table [dataSource]="productos">
          <ng-container matColumnDef="nombre">
            <th mat-header-cell *matHeaderCellDef> Nombre </th>
            <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
          </ng-container>

          <ng-container matColumnDef="descripcion">
            <th mat-header-cell *matHeaderCellDef> Descripción </th>
            <td mat-cell *matCellDef="let producto"> {{producto.descripcion}} </td>
          </ng-container>

          <ng-container matColumnDef="precio">
            <th mat-header-cell *matHeaderCellDef> Precio </th>
            <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
          </ng-container>

          <ng-container matColumnDef="stock">
            <th mat-header-cell *matHeaderCellDef> Stock </th>
            <td mat-cell *matCellDef="let producto"> {{producto.stock}} </td>
          </ng-container>

          <ng-container matColumnDef="acciones">
            <th mat-header-cell *matHeaderCellDef> Acciones </th>
            <td mat-cell *matCellDef="let producto">
              <button mat-icon-button color="primary" (click)="editarProducto(producto)">
                <mat-icon>edit</mat-icon>
              </button>
              <button mat-icon-button color="warn" (click)="confirmarEliminar(producto)">
                <mat-icon>delete</mat-icon>
              </button>
            </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="columnas"></tr>
          <tr mat-row *matRowDef="let row; columns: columnas;"></tr>
        </table>

        <mat-paginator [pageSizeOptions]="[5, 10, 20]"
                     showFirstLastButtons>
        </mat-paginator>
      </div>

      <!-- Formulario Modal -->
      <div *ngIf="mostrarFormulario" class="modal-overlay">
        <mat-card class="form-card">
          <mat-card-header>
            <mat-card-title>{{modoEdicion ? 'Editar' : 'Nuevo'}} Producto</mat-card-title>
          </mat-card-header>
          
          <mat-card-content>
            <form [formGroup]="productoForm" (ngSubmit)="guardarProducto()">
              <mat-form-field appearance="fill">
                <mat-label>Nombre</mat-label>
                <input matInput formControlName="nombre" required>
                <mat-error *ngIf="productoForm.get('nombre')?.hasError('required')">
                  El nombre es requerido
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Descripción</mat-label>
                <textarea matInput formControlName="descripcion"></textarea>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Precio</mat-label>
                <input matInput type="number" formControlName="precio" required>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('required')">
                  El precio es requerido
                </mat-error>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('min')">
                  El precio debe ser mayor a 0
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Stock</mat-label>
                <input matInput type="number" formControlName="stock">
              </mat-form-field>
            </form>
          </mat-card-content>

          <mat-card-actions align="end">
            <button mat-button (click)="cancelarEdicion()">Cancelar</button>
            <button mat-raised-button color="primary" 
                    (click)="guardarProducto()" 
                    [disabled]="productoForm.invalid">
              Guardar
            </button>
          </mat-card-actions>
        </mat-card>
      </div>
    </div>
  `,
  styles: [`
    .productos-container {
      padding: 20px;
    }
    .search-field {
      width: 100%;
      max-width: 500px;
      margin-bottom: 20px;
    }
    .add-button {
      margin-bottom: 20px;
    }
    .table-container {
      margin-top: 20px;
    }
    table {
      width: 100%;
    }
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .form-card {
      width: 100%;
      max-width: 500px;
      padding: 20px;
    }
    mat-form-field {
      width: 100%;
      margin-bottom: 16px;
    }
    .mat-column-acciones {
      width: 100px;
      text-align: center;
    }
  `]
})
export class ProductosComponent implements OnInit {
  productos: Producto[] = [];
  columnas = ['nombre', 'descripcion', 'precio', 'stock', 'acciones'];
  mostrarFormulario = false;
  modoEdicion = false;
  productoForm: FormGroup;
  productoIdEnEdicion?: number;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder,
    private snackBar: MatSnackBar
  ) {
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      descripcion: [''],
      precio: [0, [Validators.required, Validators.min(0)]],
      stock: [0]
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => this.productos = productos,
      error: (error) => this.mostrarMensaje('Error al cargar productos')
    });
  }

  buscarProducto(event: any): void {
    const nombre = event.target.value;
    if (nombre.length > 2) {
      this.productoService.searchProductosByNombre(nombre).subscribe({
        next: (productos) => this.productos = productos,
        error: (error) => this.mostrarMensaje('Error en la búsqueda')
      });
    } else if (nombre.length === 0) {
      this.cargarProductos();
    }
  }

  editarProducto(producto: Producto): void {
    this.modoEdicion = true;
    this.productoIdEnEdicion = producto.productoId;
    this.productoForm.patchValue({
      nombre: producto.nombre,
      descripcion: producto.descripcion,
      precio: producto.precio,
      stock: producto.stock
    });
    this.mostrarFormulario = true;
  }

  guardarProducto(): void {
    if (this.productoForm.valid) {
      const producto = this.productoForm.value;
      
      if (this.modoEdicion && this.productoIdEnEdicion) {
        this.productoService.actualizarProducto(this.productoIdEnEdicion, producto).subscribe({
          next: () => {
            this.mostrarMensaje('Producto actualizado exitosamente');
            this.resetearFormulario();
            this.cargarProductos();
          },
          error: (error) => this.mostrarMensaje('Error al actualizar el producto')
        });
      } else {
        this.productoService.agregarProducto(producto).subscribe({
          next: () => {
            this.mostrarMensaje('Producto agregado exitosamente');
            this.resetearFormulario();
            this.cargarProductos();
          },
          error: (error) => this.mostrarMensaje('Error al agregar el producto')
        });
      }
    }
  }

  confirmarEliminar(producto: Producto): void {
    if (confirm(`¿Está seguro de eliminar el producto ${producto.nombre}?`)) {
      this.eliminarProducto(producto.productoId!);
    }
  }

  eliminarProducto(id: number): void {
    this.productoService.eliminarProducto(id).subscribe({
      next: () => {
        this.mostrarMensaje('Producto eliminado exitosamente');
        this.cargarProductos();
      },
      error: (error) => this.mostrarMensaje('Error al eliminar el producto')
    });
  }

  cancelarEdicion(): void {
    this.resetearFormulario();
  }

  resetearFormulario(): void {
    this.mostrarFormulario = false;
    this.modoEdicion = false;
    this.productoIdEnEdicion = undefined;
    this.productoForm.reset({
      nombre: '',
      descripcion: '',
      precio: 0,
      stock: 0
    });
  }

  mostrarMensaje(mensaje: string): void {
    this.snackBar.open(mensaje, 'Cerrar', {
      duration: 3000,
      horizontalPosition: 'right',
      verticalPosition: 'top'
    });
  }
}

```

Y actualiza el AppModule para incluir los nuevos módulos de Material necesarios:

```typescript
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { RouterModule, Routes } from '@angular/router';

// Material Imports
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatToolbarModule } from '@angular/material/toolbar';

// Components
import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { ProductosComponent } from './productos/productos.component';

// Services and Guards
import { JwtInterceptor } from './interceptors/jwt.interceptor';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
```


completa el updated app module

Por supuesto, aquí está el AppModule completo:

```typescript
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { ReactiveFormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { RouterModule, Routes } from '@angular/router';

// Material Imports
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatDialogModule } from '@angular/material/dialog';

// Components
import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { ProductosComponent } from './productos/productos.component';

// Services and Guards
import { JwtInterceptor } from './interceptors/jwt.interceptor';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'productos', component: ProductosComponent, canActivate: [AuthGuard] },
  { path: '', redirectTo: '/productos', pathMatch: 'full' }
];

@NgModule({
  declarations: [
    AppComponent,
    LoginComponent,
    ProductosComponent
  ],
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    HttpClientModule,
    ReactiveFormsModule,
    RouterModule.forRoot(routes),
    // Material Modules
    MatInputModule,
    MatButtonModule,
    MatTableModule,
    MatIconModule,
    MatCardModule,
    MatFormFieldModule,
    MatSnackBarModule,
    MatPaginatorModule,
    MatToolbarModule,
    MatDialogModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true },
    AuthGuard
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

Este módulo incluye:

1. Todos los módulos de Angular Material necesarios para el componente de productos:
   - MatCardModule para las tarjetas
   - MatSnackBarModule para las notificaciones
   - MatPaginatorModule para la paginación
   - MatDialogModule para diálogos/modales

2. Las rutas básicas de la aplicación:
   - /login para la página de inicio de sesión
   - /productos para la gestión de productos (protegida por AuthGuard)
   - Redirección por defecto a productos

3. El interceptor JWT para manejar la autenticación en las peticiones HTTP

4. Todos los componentes necesarios declarados

5. Los servicios necesarios en el providers array

Para usar este módulo correctamente, asegúrate de tener instaladas todas las dependencias necesarias:

```bash
ng add @angular/material  # Si no lo has hecho ya
```

También asegúrate de que tienes los estilos de Material incluidos en tu `angular.json`:

```json
{
  "projects": {
    "your-app-name": {
      "architect": {
        "build": {
          "options": {
            "styles": [
              "@angular/material/prebuilt-themes/indigo-pink.css",
              "src/styles.css"
            ]
          }
        }
      }
    }
  }
}
```

¿Necesitas ayuda con algo más de la configuración?


asi es el objeto producto en el api
 public class Producto
 {
     public int ProductoId { get; set; }
     public string Nombre { get; set; }
     public decimal Precio { get; set; }
     public decimal? Cantidad { get; set; }
 }
 
 Actualizaré los modelos y componentes para que coincidan con la estructura del API:

```typescript
// src/app/models/producto.model.ts
export interface Producto {
  productoId?: number;
  nombre: string;
  precio: number;
  cantidad?: number;
}

```

Ahora actualizaré el componente de productos para reflejar estos cambios:

```typescript
// src/app/productos/productos.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ProductoService } from '../services/producto.service';
import { Producto } from '../models/producto.model';
import { MatSnackBar } from '@angular/material/snack-bar';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Gestión de Productos</h2>
      
      <!-- Barra de búsqueda -->
      <mat-form-field class="search-field">
        <mat-label>Buscar producto</mat-label>
        <input matInput (keyup)="buscarProducto($event)" placeholder="Nombre del producto">
        <button mat-icon-button matSuffix>
          <mat-icon>search</mat-icon>
        </button>
      </mat-form-field>

      <button mat-raised-button color="primary" (click)="mostrarFormulario = true" class="add-button">
        <mat-icon>add</mat-icon> Nuevo Producto
      </button>

      <!-- Tabla de productos -->
      <div class="mat-elevation-z8 table-container">
        <table mat-table [dataSource]="productos">
          <ng-container matColumnDef="nombre">
            <th mat-header-cell *matHeaderCellDef> Nombre </th>
            <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
          </ng-container>

          <ng-container matColumnDef="precio">
            <th mat-header-cell *matHeaderCellDef> Precio </th>
            <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
          </ng-container>

          <ng-container matColumnDef="cantidad">
            <th mat-header-cell *matHeaderCellDef> Cantidad </th>
            <td mat-cell *matCellDef="let producto"> {{producto.cantidad || 0}} </td>
          </ng-container>

          <ng-container matColumnDef="acciones">
            <th mat-header-cell *matHeaderCellDef> Acciones </th>
            <td mat-cell *matCellDef="let producto">
              <button mat-icon-button color="primary" (click)="editarProducto(producto)">
                <mat-icon>edit</mat-icon>
              </button>
              <button mat-icon-button color="warn" (click)="confirmarEliminar(producto)">
                <mat-icon>delete</mat-icon>
              </button>
            </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="columnas"></tr>
          <tr mat-row *matRowDef="let row; columns: columnas;"></tr>
        </table>

        <mat-paginator [pageSizeOptions]="[5, 10, 20]"
                     showFirstLastButtons>
        </mat-paginator>
      </div>

      <!-- Formulario Modal -->
      <div *ngIf="mostrarFormulario" class="modal-overlay">
        <mat-card class="form-card">
          <mat-card-header>
            <mat-card-title>{{modoEdicion ? 'Editar' : 'Nuevo'}} Producto</mat-card-title>
          </mat-card-header>
          
          <mat-card-content>
            <form [formGroup]="productoForm" (ngSubmit)="guardarProducto()">
              <mat-form-field appearance="fill">
                <mat-label>Nombre</mat-label>
                <input matInput formControlName="nombre" required>
                <mat-error *ngIf="productoForm.get('nombre')?.hasError('required')">
                  El nombre es requerido
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Precio</mat-label>
                <input matInput type="number" formControlName="precio" required>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('required')">
                  El precio es requerido
                </mat-error>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('min')">
                  El precio debe ser mayor a 0
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Cantidad</mat-label>
                <input matInput type="number" formControlName="cantidad">
              </mat-form-field>
            </form>
          </mat-card-content>

          <mat-card-actions align="end">
            <button mat-button (click)="cancelarEdicion()">Cancelar</button>
            <button mat-raised-button color="primary" 
                    (click)="guardarProducto()" 
                    [disabled]="productoForm.invalid">
              Guardar
            </button>
          </mat-card-actions>
        </mat-card>
      </div>
    </div>
  `,
  styles: [`
    .productos-container {
      padding: 20px;
    }
    .search-field {
      width: 100%;
      max-width: 500px;
      margin-bottom: 20px;
    }
    .add-button {
      margin-bottom: 20px;
    }
    .table-container {
      margin-top: 20px;
    }
    table {
      width: 100%;
    }
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .form-card {
      width: 100%;
      max-width: 500px;
      padding: 20px;
    }
    mat-form-field {
      width: 100%;
      margin-bottom: 16px;
    }
    .mat-column-acciones {
      width: 100px;
      text-align: center;
    }
  `]
})
export class ProductosComponent implements OnInit {
  productos: Producto[] = [];
  columnas = ['nombre', 'precio', 'cantidad', 'acciones'];
  mostrarFormulario = false;
  modoEdicion = false;
  productoForm: FormGroup;
  productoIdEnEdicion?: number;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder,
    private snackBar: MatSnackBar
  ) {
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      precio: [0, [Validators.required, Validators.min(0)]],
      cantidad: [0]
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => this.productos = productos,
      error: (error) => this.mostrarMensaje('Error al cargar productos')
    });
  }

  buscarProducto(event: any): void {
    const nombre = event.target.value;
    if (nombre.length > 2) {
      this.productoService.searchProductosByNombre(nombre).subscribe({
        next: (productos) => this.productos = productos,
        error: (error) => this.mostrarMensaje('Error en la búsqueda')
      });
    } else if (nombre.length === 0) {
      this.cargarProductos();
    }
  }

  editarProducto(producto: Producto): void {
    this.modoEdicion = true;
    this.productoIdEnEdicion = producto.productoId;
    this.productoForm.patchValue({
      nombre: producto.nombre,
      precio: producto.precio,
      cantidad: producto.cantidad || 0
    });
    this.mostrarFormulario = true;
  }

  guardarProducto(): void {
    if (this.productoForm.valid) {
      const producto = this.productoForm.value;
      
      if (this.modoEdicion && this.productoIdEnEdicion) {
        producto.productoId = this.productoIdEnEdicion;
        this.productoService.actualizarProducto(this.productoIdEnEdicion, producto).subscribe({
          next: () => {
            this.mostrarMensaje('Producto actualizado exitosamente');
            this.resetearFormulario();
            this.cargarProductos();
          },
          error: (error) => this.mostrarMensaje('Error al actualizar el producto')
        });
      } else {
        this.productoService.agregarProducto(producto).subscribe({
          next: () => {
            this.mostrarMensaje('Producto agregado exitosamente');
            this.resetearFormulario();
            this.cargarProductos();
          },
          error: (error) => this.mostrarMensaje('Error al agregar el producto')
        });
      }
    }
  }

  confirmarEliminar(producto: Producto): void {
    if (confirm(`¿Está seguro de eliminar el producto ${producto.nombre}?`)) {
      this.eliminarProducto(producto.productoId!);
    }
  }

  eliminarProducto(id: number): void {
    this.productoService.eliminarProducto(id).subscribe({
      next: () => {
        this.mostrarMensaje('Producto eliminado exitosamente');
        this.cargarProductos();
      },
      error: (error) => this.mostrarMensaje('Error al eliminar el producto')
    });
  }

  cancelarEdicion(): void {
    this.resetearFormulario();
  }

  resetearFormulario(): void {
    this.mostrarFormulario = false;
    this.modoEdicion = false;
    this.productoIdEnEdicion = undefined;
    this.productoForm.reset({
      nombre: '',
      precio: 0,
      cantidad: 0
    });
  }

  mostrarMensaje(mensaje: string): void {
    this.snackBar.open(mensaje, 'Cerrar', {
      duration: 3000,
      horizontalPosition: 'right',
      verticalPosition: 'top'
    });
  }
}

```

Los principales cambios incluyen:

1. Actualización del modelo de Producto para coincidir con el API
2. Eliminación de campos no utilizados (descripción, stock)
3. Cambio de 'stock' por 'cantidad' en la interfaz
4. Ajuste de los campos del formulario para coincidir con el modelo
5. Actualización de la tabla para mostrar los campos correctos

¿Necesitas ayuda con algo más de la implementación?

ERROR Error: Provided data source did not match an array, Observable, or DataSource
    at getTableUnknownDataSourceError (table.mjs:1511:10)
    at MatTable.observeRenderChanges (table.mjs:2387:13)
    at MatTable.render (table.mjs:2239:12)
    at _MatTable.ngAfterContentChecked (table.mjs:2003:12)
    at callHookInternal (core.mjs:5008:10)
    at callHook (core.mjs:5035:5)
    at callHooks (core.mjs:4992:9)
    at executeCheckHooks (core.mjs:4929:3)
    at refreshView (core.mjs:13373:11)
    at detectChangesInView (core.mjs:13543:5)

Este es response de GET /api/Producto
{
  "data": [
    {
      "productoId": 2,
      "nombre": "primer producto",
      "precio": 10,
      "cantidad": 1
    }
  ],
  "totalRecords": 1
}

Ah, ya veo. El problema es que la API devuelve un objeto con una estructura que incluye `data` y `totalRecords`. Vamos a actualizar el servicio y el componente para manejar esta estructura:

```typescript
// src/app/models/producto.model.ts
export interface Producto {
  productoId?: number;
  nombre: string;
  precio: number;
  cantidad?: number;
}

export interface ProductoResponse {
  data: Producto[];
  totalRecords: number;
}

```

Ahora actualizamos el servicio:

```typescript
// src/app/services/producto.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, map } from 'rxjs';
import { Producto, ProductoResponse } from '../models/producto.model';

@Injectable({
  providedIn: 'root'
})
export class ProductoService {
  private apiUrl = 'https://localhost:7187/api/Producto';
  
  private httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    }),
    withCredentials: true
  };

  constructor(private http: HttpClient) { }

  // Obtener todos los productos
  getProductos(): Observable<Producto[]> {
    return this.http.get<ProductoResponse>(this.apiUrl, this.httpOptions)
      .pipe(
        map(response => response.data)
      );
  }

  // Obtener un producto por ID
  getProductoById(id: number): Observable<Producto> {
    return this.http.get<Producto>(`${this.apiUrl}/${id}`, this.httpOptions);
  }

  // Buscar productos por nombre
  searchProductosByNombre(nombre: string): Observable<Producto[]> {
    return this.http.get<ProductoResponse>(`${this.apiUrl}/${encodeURIComponent(nombre)}`, this.httpOptions)
      .pipe(
        map(response => response.data)
      );
  }

  // Agregar nuevo producto
  agregarProducto(producto: Producto): Observable<Producto> {
    return this.http.post<Producto>(this.apiUrl, producto, this.httpOptions);
  }

  // Actualizar producto existente
  actualizarProducto(id: number, producto: Producto): Observable<Producto> {
    return this.http.put<Producto>(`${this.apiUrl}/${id}`, producto, this.httpOptions);
  }

  // Eliminar producto
  eliminarProducto(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`, this.httpOptions);
  }
}

```

Y actualizamos el componente para trabajar con MatTableDataSource:

```typescript
// src/app/productos/productos.component.ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ProductoService } from '../services/producto.service';
import { Producto } from '../models/producto.model';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Gestión de Productos</h2>
      
      <!-- Barra de búsqueda -->
      <mat-form-field class="search-field">
        <mat-label>Buscar producto</mat-label>
        <input matInput (keyup)="filtrarProductos($event)" placeholder="Nombre del producto">
        <button mat-icon-button matSuffix>
          <mat-icon>search</mat-icon>
        </button>
      </mat-form-field>

      <button mat-raised-button color="primary" (click)="mostrarFormulario = true" class="add-button">
        <mat-icon>add</mat-icon> Nuevo Producto
      </button>

      <!-- Tabla de productos -->
      <div class="mat-elevation-z8 table-container">
        <table mat-table [dataSource]="dataSource">
          <ng-container matColumnDef="nombre">
            <th mat-header-cell *matHeaderCellDef> Nombre </th>
            <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
          </ng-container>

          <ng-container matColumnDef="precio">
            <th mat-header-cell *matHeaderCellDef> Precio </th>
            <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
          </ng-container>

          <ng-container matColumnDef="cantidad">
            <th mat-header-cell *matHeaderCellDef> Cantidad </th>
            <td mat-cell *matCellDef="let producto"> {{producto.cantidad || 0}} </td>
          </ng-container>

          <ng-container matColumnDef="acciones">
            <th mat-header-cell *matHeaderCellDef> Acciones </th>
            <td mat-cell *matCellDef="let producto">
              <button mat-icon-button color="primary" (click)="editarProducto(producto)">
                <mat-icon>edit</mat-icon>
              </button>
              <button mat-icon-button color="warn" (click)="confirmarEliminar(producto)">
                <mat-icon>delete</mat-icon>
              </button>
            </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="columnas"></tr>
          <tr mat-row *matRowDef="let row; columns: columnas;"></tr>
        </table>

        <mat-paginator [pageSizeOptions]="[5, 10, 20]"
                     showFirstLastButtons>
        </mat-paginator>
      </div>

      <!-- Formulario Modal -->
      <div *ngIf="mostrarFormulario" class="modal-overlay">
        <mat-card class="form-card">
          <mat-card-header>
            <mat-card-title>{{modoEdicion ? 'Editar' : 'Nuevo'}} Producto</mat-card-title>
          </mat-card-header>
          
          <mat-card-content>
            <form [formGroup]="productoForm" (ngSubmit)="guardarProducto()">
              <mat-form-field appearance="fill">
                <mat-label>Nombre</mat-label>
                <input matInput formControlName="nombre" required>
                <mat-error *ngIf="productoForm.get('nombre')?.hasError('required')">
                  El nombre es requerido
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Precio</mat-label>
                <input matInput type="number" formControlName="precio" required>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('required')">
                  El precio es requerido
                </mat-error>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('min')">
                  El precio debe ser mayor a 0
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Cantidad</mat-label>
                <input matInput type="number" formControlName="cantidad">
              </mat-form-field>
            </form>
          </mat-card-content>

          <mat-card-actions align="end">
            <button mat-button (click)="cancelarEdicion()">Cancelar</button>
            <button mat-raised-button color="primary" 
                    (click)="guardarProducto()" 
                    [disabled]="productoForm.invalid">
              Guardar
            </button>
          </mat-card-actions>
        </mat-card>
      </div>
    </div>
  `,
  // ... styles permanecen igual ...
})
export class ProductosComponent implements OnInit {
  dataSource: MatTableDataSource<Producto>;
  columnas = ['nombre', 'precio', 'cantidad', 'acciones'];
  mostrarFormulario = false;
  modoEdicion = false;
  productoForm: FormGroup;
  productoIdEnEdicion?: number;

  @ViewChild(MatPaginator) paginator!: MatPaginator;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder,
    private snackBar: MatSnackBar
  ) {
    this.dataSource = new MatTableDataSource<Producto>([]);
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      precio: [0, [Validators.required, Validators.min(0)]],
      cantidad: [0]
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => {
        this.dataSource.data = productos;
      },
      error: (error) => this.mostrarMensaje('Error al cargar productos')
    });
  }

  filtrarProductos(event: Event): void {
    const filterValue = (event.target as HTMLInputElement).value;
    this.dataSource.filter = filterValue.trim().toLowerCase();
  }

  // ... resto de métodos permanecen igual ...
}

```

Los cambios principales son:

1. Agregado interface `ProductoResponse` para manejar la estructura de respuesta de la API
2. Actualizado el servicio para usar `map` y extraer el array de productos de la respuesta
3. Cambiado el array simple por `MatTableDataSource` en el componente
4. Agregado `ViewChild` para el paginador
5. Implementado método de filtrado local
6. Actualizada la forma de asignar datos a la tabla

Ahora la tabla debería funcionar correctamente con los datos de la API. ¿Necesitas ayuda con algo más?

el problema es que la API devuelve distintos formatos te comparto el controller

using Entity;
using Entity.Common;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Services;
using System.ComponentModel.DataAnnotations;
namespace GestionProductosAPI.Controllers
{
    [Authorize]
    [ApiController]
    [Route("api/[controller]")]
    public class ProductoController : ControllerBase
    {
        private readonly IProductoService _productoService;
        public ProductoController(IProductoService productoService)
        {
            _productoService = productoService;
        }
        [Authorize]
        [HttpGet("{id}")]
        public async Task<IActionResult> GetProducto(int id)
        {
            var result = await _productoService.GetProductoByIdAsync(id);
            return Ok(result.Data);
        }
        [HttpGet]
        public async Task<IActionResult> GetProductos()
        {
            var result = await _productoService.GetAllProductosAsync();
            return Ok(new
            {
                Data = result.Data,
                TotalRecords = result.TotalRecords
            });
        }
        [Authorize]
        [HttpGet("/search")]
        public async Task<ActionResult<Result<IEnumerable<Producto>>>> GetProductos([FromQuery] string? nombre = null)
        {
            var result = await _productoService.GetProductosByNombre(nombre);
            return Ok(result);
        }
        [Authorize]
        [HttpPost]
        public async Task<IActionResult> CreateProducto(Producto producto)
        {
            var result = await _productoService.CreateProductoAsync(producto);
            return CreatedAtAction(nameof(GetProducto), new { id = result.Data.ProductoId }, result.Data);
        }
        [Authorize]
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateProducto(int id, Producto producto)
        {
            var result = await _productoService.UpdateProductoAsync(id, producto);
            return Ok(result.Data);
        }
        [Authorize]
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteProducto(int id)
        {
            var result = await _productoService.DeleteProductoAsync(id);
            return NoContent();
        }
    }
}

 Deberia devolver siempre esta clase
public class Result<T>
{
    public bool IsSuccess { get; }
    public T Data { get; }
    public string Error { get; }
    public int StatusCode { get; }
    protected Result(bool isSuccess, T data, string error, int statusCode)
    {
        IsSuccess = isSuccess;
        Data = data;
        Error = error;
        StatusCode = statusCode;
    }
    public static Result<T> Success(T data, int statusCode = 200)
    {
        return new Result<T>(true, data, null, statusCode);
    }
    public static Result<T> Failure(string error, int statusCode = 400)
    {
        return new Result<T>(false, default, error, statusCode);
    }
}

Entiendo, el problema es que algunos endpoints devuelven directamente `result.Data` y otros devuelven el objeto `Result<T>` completo. Vamos a modificar el controller para que sea consistente:

```csharp
[Authorize]
[ApiController]
[Route("api/[controller]")]
public class ProductoController : ControllerBase
{
    private readonly IProductoService _productoService;
    
    public ProductoController(IProductoService productoService)
    {
        _productoService = productoService;
    }

    [Authorize]
    [HttpGet("{id}")]
    public async Task<ActionResult<Result<Producto>>> GetProducto(int id)
    {
        var result = await _productoService.GetProductoByIdAsync(id);
        return Ok(result);  // Devolver el Result completo
    }

    [HttpGet]
    public async Task<ActionResult<Result<IEnumerable<Producto>>>> GetProductos()
    {
        var result = await _productoService.GetAllProductosAsync();
        return Ok(result);  // Devolver el Result completo
    }

    [Authorize]
    [HttpGet("search")]  // Corregido el path
    public async Task<ActionResult<Result<IEnumerable<Producto>>>> GetProductos([FromQuery] string? nombre = null)
    {
        var result = await _productoService.GetProductosByNombre(nombre);
        return Ok(result);
    }

    [Authorize]
    [HttpPost]
    public async Task<ActionResult<Result<Producto>>> CreateProducto(Producto producto)
    {
        var result = await _productoService.CreateProductoAsync(producto);
        return Created($"api/Producto/{result.Data.ProductoId}", result);  // Devolver el Result completo
    }

    [Authorize]
    [HttpPut("{id}")]
    public async Task<ActionResult<Result<Producto>>> UpdateProducto(int id, Producto producto)
    {
        var result = await _productoService.UpdateProductoAsync(id, producto);
        return Ok(result);  // Devolver el Result completo
    }

    [Authorize]
    [HttpDelete("{id}")]
    public async Task<ActionResult<Result<bool>>> DeleteProducto(int id)
    {
        var result = await _productoService.DeleteProductoAsync(id);
        return Ok(result);  // Devolver el Result completo en lugar de NoContent
    }
}

```

Ahora actualizamos el servicio en Angular para manejar el formato consistente:

```typescript
// src/app/models/api-response.model.ts
export interface ApiResult<T> {
  isSuccess: boolean;
  data: T;
  error: string | null;
  statusCode: number;
}

// src/app/services/producto.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Producto } from '../models/producto.model';
import { ApiResult } from '../models/api-response.model';

@Injectable({
  providedIn: 'root'
})
export class ProductoService {
  private apiUrl = 'https://localhost:7187/api/Producto';
  
  private httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    }),
    withCredentials: true
  };

  constructor(private http: HttpClient) { }

  private handleError(error: HttpErrorResponse) {
    if (error.error instanceof ErrorEvent) {
      return throwError(() => error.error.message);
    }
    
    // Si es un error de la API, intentamos obtener el mensaje de error
    if (error.error && typeof error.error === 'object') {
      const apiError = error.error as ApiResult<any>;
      return throwError(() => apiError.error || 'Error del servidor');
    }
    
    return throwError(() => 'Error del servidor');
  }

  getProductos(): Observable<Producto[]> {
    return this.http.get<ApiResult<Producto[]>>(this.apiUrl, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error al obtener productos');
        }
        return result.data;
      }),
      catchError(this.handleError)
    );
  }

  getProductoById(id: number): Observable<Producto> {
    return this.http.get<ApiResult<Producto>>(`${this.apiUrl}/${id}`, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error al obtener el producto');
        }
        return result.data;
      }),
      catchError(this.handleError)
    );
  }

  searchProductosByNombre(nombre: string): Observable<Producto[]> {
    return this.http.get<ApiResult<Producto[]>>(`${this.apiUrl}/search?nombre=${encodeURIComponent(nombre)}`, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error en la búsqueda');
        }
        return result.data;
      }),
      catchError(this.handleError)
    );
  }

  agregarProducto(producto: Producto): Observable<Producto> {
    return this.http.post<ApiResult<Producto>>(this.apiUrl, producto, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error al crear el producto');
        }
        return result.data;
      }),
      catchError(this.handleError)
    );
  }

  actualizarProducto(id: number, producto: Producto): Observable<Producto> {
    return this.http.put<ApiResult<Producto>>(`${this.apiUrl}/${id}`, producto, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error al actualizar el producto');
        }
        return result.data;
      }),
      catchError(this.handleError)
    );
  }

  eliminarProducto(id: number): Observable<void> {
    return this.http.delete<ApiResult<void>>(`${this.apiUrl}/${id}`, this.httpOptions).pipe(
      map(result => {
        if (!result.isSuccess) {
          throw new Error(result.error || 'Error al eliminar el producto');
        }
      }),
      catchError(this.handleError)
    );
  }
}

```

Los cambios principales son:

1. El controller ahora devuelve consistentemente objetos `Result<T>`
2. El servicio en Angular maneja un formato único de respuesta
3. Mejor manejo de errores basado en la estructura de `Result<T>`
4. La ruta de búsqueda se corrigió a `/search`
5. Validación consistente de `isSuccess` antes de devolver los datos

¿Necesitas ayuda para implementar estos cambios o tienes alguna pregunta adicional?

quita los iconos porque se ven mal, utiliza las palabras nuevo editar eliminar, ademas agrega un boton buscar porque sino tengo que escribir 3 digitos para la busqueda

Te ayudo a actualizar el componente de productos con esos cambios:

```typescript
// src/app/productos/productos.component.ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator } from '@angular/material/paginator';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ProductoService } from '../services/producto.service';
import { Producto } from '../models/producto.model';

@Component({
  selector: 'app-productos',
  template: `
    <div class="productos-container">
      <h2>Gestión de Productos</h2>
      
      <div class="actions-container">
        <!-- Barra de búsqueda -->
        <div class="search-container">
          <mat-form-field class="search-field">
            <mat-label>Buscar producto</mat-label>
            <input matInput [(ngModel)]="searchTerm" name="searchTerm" placeholder="Nombre del producto">
          </mat-form-field>
          <button mat-raised-button color="primary" (click)="buscarProducto()">
            Buscar
          </button>
        </div>

        <button mat-raised-button color="primary" (click)="mostrarFormulario = true">
          Nuevo Producto
        </button>
      </div>

      <!-- Tabla de productos -->
      <div class="mat-elevation-z8 table-container">
        <table mat-table [dataSource]="dataSource">
          <ng-container matColumnDef="nombre">
            <th mat-header-cell *matHeaderCellDef> Nombre </th>
            <td mat-cell *matCellDef="let producto"> {{producto.nombre}} </td>
          </ng-container>

          <ng-container matColumnDef="precio">
            <th mat-header-cell *matHeaderCellDef> Precio </th>
            <td mat-cell *matCellDef="let producto"> {{producto.precio | currency}} </td>
          </ng-container>

          <ng-container matColumnDef="cantidad">
            <th mat-header-cell *matHeaderCellDef> Cantidad </th>
            <td mat-cell *matCellDef="let producto"> {{producto.cantidad || 0}} </td>
          </ng-container>

          <ng-container matColumnDef="acciones">
            <th mat-header-cell *matHeaderCellDef> Acciones </th>
            <td mat-cell *matCellDef="let producto">
              <button mat-button color="primary" (click)="editarProducto(producto)">
                Editar
              </button>
              <button mat-button color="warn" (click)="confirmarEliminar(producto)">
                Eliminar
              </button>
            </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="columnas"></tr>
          <tr mat-row *matRowDef="let row; columns: columnas;"></tr>

          <!-- Fila para cuando no hay datos -->
          <tr class="mat-row" *matNoDataRow>
            <td class="mat-cell" colspan="4">No se encontraron productos</td>
          </tr>
        </table>

        <mat-paginator [pageSizeOptions]="[5, 10, 20]" showFirstLastButtons>
        </mat-paginator>
      </div>

      <!-- Modal de formulario -->
      <div *ngIf="mostrarFormulario" class="modal-overlay">
        <mat-card class="form-card">
          <mat-card-header>
            <mat-card-title>{{modoEdicion ? 'Editar' : 'Nuevo'}} Producto</mat-card-title>
          </mat-card-header>
          
          <mat-card-content>
            <form [formGroup]="productoForm" (ngSubmit)="guardarProducto()">
              <mat-form-field appearance="fill">
                <mat-label>Nombre</mat-label>
                <input matInput formControlName="nombre" required>
                <mat-error *ngIf="productoForm.get('nombre')?.hasError('required')">
                  El nombre es requerido
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Precio</mat-label>
                <input matInput type="number" formControlName="precio" required>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('required')">
                  El precio es requerido
                </mat-error>
                <mat-error *ngIf="productoForm.get('precio')?.hasError('min')">
                  El precio debe ser mayor a 0
                </mat-error>
              </mat-form-field>

              <mat-form-field appearance="fill">
                <mat-label>Cantidad</mat-label>
                <input matInput type="number" formControlName="cantidad">
              </mat-form-field>
            </form>
          </mat-card-content>

          <mat-card-actions align="end">
            <button mat-button (click)="cancelarEdicion()">Cancelar</button>
            <button mat-raised-button color="primary" 
                    (click)="guardarProducto()" 
                    [disabled]="productoForm.invalid">
              Guardar
            </button>
          </mat-card-actions>
        </mat-card>
      </div>
    </div>
  `,
  styles: [`
    .productos-container {
      padding: 20px;
    }
    .actions-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .search-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .search-field {
      width: 300px;
    }
    .table-container {
      position: relative;
      min-height: 200px;
    }
    table {
      width: 100%;
    }
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .form-card {
      width: 100%;
      max-width: 500px;
      padding: 20px;
    }
    mat-form-field {
      width: 100%;
      margin-bottom: 16px;
    }
    .mat-column-acciones {
      text-align: right;
      padding-right: 16px;
    }
    td.mat-cell {
      padding: 16px;
    }
  `]
})
export class ProductosComponent implements OnInit {
  dataSource: MatTableDataSource<Producto>;
  columnas = ['nombre', 'precio', 'cantidad', 'acciones'];
  mostrarFormulario = false;
  modoEdicion = false;
  productoForm: FormGroup;
  productoIdEnEdicion?: number;
  searchTerm: string = '';

  @ViewChild(MatPaginator) paginator!: MatPaginator;

  constructor(
    private productoService: ProductoService,
    private fb: FormBuilder,
    private snackBar: MatSnackBar
  ) {
    this.dataSource = new MatTableDataSource<Producto>([]);
    this.productoForm = this.fb.group({
      nombre: ['', Validators.required],
      precio: [0, [Validators.required, Validators.min(0)]],
      cantidad: [0]
    });
  }

  ngOnInit(): void {
    this.cargarProductos();
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
  }

  cargarProductos(): void {
    this.productoService.getProductos().subscribe({
      next: (productos) => {
        this.dataSource.data = productos;
      },
      error: (error) => this.mostrarMensaje(error)
    });
  }

  buscarProducto(): void {
    const nombre = this.searchTerm.trim();
    
    if (!nombre) {
      this.cargarProductos();
      return;
    }

    this.productoService.searchProductosByNombre(nombre).subscribe({
      next: (productos) => {
        this.dataSource.data = productos;
      },
      error: (error) => {
        this.mostrarMensaje(error);
      }
    });
  }

  // ... resto de los métodos permanecen igual ...
}

```

Los cambios principales son:

1. Quitados los iconos y reemplazados por texto en los botones
2. Agregado un campo de búsqueda con ngModel y un botón de búsqueda dedicado
3. Reorganizada la interfaz para mejor usabilidad
4. Mejorado el espaciado y alineación de los elementos
5. La búsqueda ahora se realiza explícitamente al hacer clic en el botón

También necesitarás asegurarte de que FormsModule esté importado en tu AppModule para que funcione el ngModel:

```typescript
// src/app/app.module.ts
import { FormsModule, ReactiveFormsModule } from '@angular/forms';

@NgModule({
  // ...
  imports: [
    // ...otros imports
    FormsModule,
    ReactiveFormsModule,
    // ...resto de imports
  ],
  // ...
})
export class AppModule { }

```

¿Necesitas ayuda con algo más o quieres hacer algún otro ajuste en la interfaz?

No suitable injection token for parameter 'fb' of class 'ProductosComponent'.
  Consider using the @Inject decorator to specify an injection token.
  
  Este error ocurre porque falta importar el ReactiveFormsModule en el AppModule. Vamos a actualizar el módulo:

```typescript
// src/app/app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { RouterModule, Routes } from '@angular/router';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';

// Material Modules
import { MatTableModule } from '@angular/material/table';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatInputModule } from '@angular/material/input';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatToolbarModule } from '@angular/material/toolbar';

// Components
import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { ProductosComponent } from './productos/productos.component';

// Services and Guards
import { JwtInterceptor } from './interceptors/jwt.interceptor';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'productos', component: ProductosComponent, canActivate: [AuthGuard] },
  { path: '', redirectTo: '/productos', pathMatch: 'full' }
];

@NgModule({
  declarations: [
    AppComponent,
    LoginComponent,
    ProductosComponent
  ],
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    HttpClientModule,
    FormsModule,                // Para ngModel
    ReactiveFormsModule,        // Para FormBuilder y formularios reactivos
    RouterModule.forRoot(routes),
    // Material Modules
    MatTableModule,
    MatPaginatorModule,
    MatInputModule,
    MatButtonModule,
    MatCardModule,
    MatFormFieldModule,
    MatSnackBarModule,
    MatToolbarModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

Principales cambios:
1. Agregado `FormsModule` para el ngModel en el campo de búsqueda
2. Agregado `ReactiveFormsModule` para el FormBuilder y formularios reactivos
3. Ordenados los imports para mejor claridad
4. Asegurado que todos los módulos de Material necesarios están importados

Ahora el FormBuilder debería estar disponible para la inyección de dependencias en el componente ProductosComponent. ¿Necesitas ayuda con algo más?